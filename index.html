<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        body
        {
            margin: 0;
            overflow: hidden;
        }

    </style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4;
        const vec3 = glMatrix.vec3;
        const vec2 = glMatrix.vec2;
        // Converts from degrees to radians.
        Math.radians = function(degrees) {
          return degrees * Math.PI / 180;
        };
         
        // Converts from radians to degrees.
        Math.degrees = function(radians) {
          return radians * 180 / Math.PI;
        };
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord

uniform mat4 model;

uniform UBO {
    mat4 projection;
    mat4 view;
};

out vec3 normal;
out vec3 fragPos;
out vec2 vTexCoord;

void main( )
{
    fragPos = vec3(model * vec4(aPos, 1.0));
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    mat3 normalM = mat3(transpose(inverse(model)));
    normal = normalM * aNormal;

    vTexCoord = aTexCoord;
}

</script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

out vec4 fragColor;

void main( )
{
    fragColor = vec4(1.0,1.0,1.0,1.0);
}
</script>

</head>
<body>
<canvas id="myCanvas" width="1024" height="760"></canvas>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );

    // ---------------------------------------------------
    // CREAR TODOS LOS SHADERPROGRAMS QUE NECESITES
    // ---------------------------------------------------
    let shaderProgram = new ShaderProgram( );

    // ---------------------------------------------------
    // CREAMOS EL UBO Y VINCULAMOS TODOS LOS SHADERPROGRAM
    // QUE HARÁN USO DE ESTE UBO
    // ---------------------------------------------------
    // TODO: ShaderProgram debe ser algún Programa que crees y que contenga el UBO
    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view" ]); // Aquí añade todos los uniformes que quieres compartir

ubo.attachProgram( shaderProgram );
    // TODO: Realiza esta llamada con cada programa que vayas a utilizar 
    // ubo.attachProgram( shaderProgram );


    // ---------------------------------------------------
const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    let VAO, VBO, VBO2, VBO3, VBO4, EBO;
    VAO = gl.createVertexArray();
    VBO = gl.createBuffer();
    VBO2 = gl.createBuffer();
    VBO3 = gl.createBuffer();
    VBO4 = gl.createBuffer();
    EBO = gl.createBuffer();
    gl.bindVertexArray(VAO);
    // position attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);
    // normal attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.normals), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(1);
    // texCoord attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.uvs), gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(2);
    // index attribute
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphereGeo.indices), gl.STATIC_DRAW);
    // Unbind the VBO
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    // Unbind the VAO
    gl.bindVertexArray(null);

    // CREA EL VAO, VBO'S Y EBO PARA LA ESFERA (createSphere())
    // CREA EL VAO, VOB'S Y EBO PARA EL ANILLO (createRing())
    //  {
    //    "vertices": vertices,
    //    normals: normals,
    //    texCoords: uvs,
    //    indices: indices
    // }
    // ---------------------------------------------------
    // TODO: Crea una esfera y sube la geometría a la tarjeta gráfica

    shaderProgram.autocatching();

    var timeAccel = 1;
    var earthDistance = 10;
    var moonDistance = 2;
    var sunPos = [0.0, 0.0, 0.0];

    var earthYearDuration = 365.0;
    var moonYearDuration = 28.0;

    var earthDayNumber = 365.0;

    gl.clearColor( 1.0, 0.5, 0.0, 1.0 );
    gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
    // --------------------------------------------------------------------
    // ------------------------{ RENDER FUNC }-----------------------------
    // --------------------------------------------------------------------
    function renderFunc( time )
    {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );

        time *= 0.001 * timeAccel; // to seconds

    	var proj = mat4.create( );
    	mat4.perspective(proj, Math.radians( 60.0 ), gl.canvas.width/gl.canvas.height, 0.001, 1000.0 );
    	var view = mat4.create( );

        // TODO: Tienes que activar al menos un programa
        shaderProgram.bind( );

        // Aquí subimos los datos para la proyección y la vista
        ubo.uploadData( "projection", proj );
        ubo.uploadData( "view", view );
        ubo.uploadAll( ); // Esta llamada sube todos los datos de golpe
        
        // A partir de aquí, subimos matriz model y demás cosas para cada esfera.


        let modelSun = mat4.create();
        let modelEarth = mat4.create();
        let modelMoon = mat4.create();


        mat4.translate(modelSun, modelSun, sunPos);

        var earthTime = time / earthYearDuration;
        var earthPosX = cos(earthTime);
        var earthPosZ = sin(earthTime);
        var earthPos = sunPos + [earthPosX, 0.0, earthPosZ] * earthDistance;
        mat4.translate(modelEarth, modelEarth, earthPos);
        mat4.rotate(modelEarth, modelEarth, Math.radians(earthTime * earthDayNumber), [0.0 ,1.0, 0.0]);
        
        var moonTime = time / 28;
        var moonPosX = cos(moonTime);
        var moonPosZ = sin(moonTime);
        var moonPos = earthPos + [moonPosX, 0.0, moonPosZ] * moonDistance;
        mat4.translate(modelMoon, modelMoon, moonPos);

        var moonDirection = earthPos - moonPos;
        vec3.normalize(moonDirection, moonDirection);
        var moonAngle = vec3.dot(moonDirection, [1.0, 0.0, 0.0]);
        mat4.rotate(modelMoon, modelMoon, Math.radians(moonAngle), [0.0 ,1.0, 0.0]);
        
        var models = [modelSun, modelEarth, modelMoon];
        for(var i = 0; i < models.length; i ++) {
            shaderProgram.setUniformMat4("model", models[i]);
            gl.drawElements(gl.TRIANGLES, 32, gl.UNSIGNED_INT, 0);
        }
        
        

        requestAnimationFrame( renderFunc );
    }

    document.addEventListener('keydown', function(event) {
        /*
            65 => A
            68 => D
            83 => S
            87 => W
            81 => Q
            69 => E

            37 => Flecha izq
            39 => Fecha drcha
            38 => Fecha arriba
            40 => Fecha abajo

        */
        if( event.keyCode == 81 ) // Q
        {
        }
        
    } );

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.clientWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>