<!DOCTYPE html>
<html>
<head>
    <title>Pr√°c.2 Remi y Stefano</title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">/*canvas {width: 100%;height: 100%;display: block;}body{margin: 0;overflow: hidden;}*/</style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4; const vec3 = glMatrix.vec3; const vec2 = glMatrix.vec2;
        Math.radians = function(degrees) {return degrees * Math.PI / 180;};
        Math.degrees = function(radians) {return radians * 180 / Math.PI;};
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

uniform mat4 model;

uniform UBO {
    mat4 projection;
    mat4 view;
};  

out vec3 normal;
out vec3 fragPos;
out vec2 vTexCoord;

void main( )
{
    fragPos = vec3(model * vec4(aPos, 1.0));
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    mat3 normalM = mat3(transpose(inverse(model)));
    normal = normalM * aNormal;

    vTexCoord = aTexCoord;
}
</script>

<script id="earth-shader-fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec3 normal;
in vec3 fragPos;
in vec2 vTexCoord;

out vec4 fragColor;

uniform sampler2D cloudsTexture;
uniform sampler2D diffuseTexture;
uniform sampler2D normalTexture;
uniform sampler2D specularTexture;

void main(){
    fragColor = vec4(texture(diffuseTexture, vTexCoord).rgb, 1.0);
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    
    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    
    uniform sampler2D planetTexture;
    
    void main(){
        fragColor = vec4(1.0,1.0,1.0,1.0);
    }
    </script>

</head>
<body>
<canvas id="myCanvas" width="1024" height="1024"></canvas>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );
    let shaderProgram = new ShaderProgram( );
    let earthShaderProgram = new ShaderProgram();
    shaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    shaderProgram.createFragmentShader(document.getElementById( "shader-fs" ).text);
    earthShaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    earthShaderProgram.createFragmentShader(document.getElementById( "earth-shader-fs" ).text);
    shaderProgram.compile(); shaderProgram.link(); shaderProgram.autocatching();
    earthShaderProgram.compile(); earthShaderProgram.link(); earthShaderProgram.autocatching();

    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view" ]); 
    ubo.attachProgram(shaderProgram); ubo.attachProgram(earthShaderProgram);
    gl.clearColor( 1.0, 0.5, 0.0, 1.0 ); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    

    // ---------------------------------------------------
    const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    let VAO;
    let VBOsphereVert, VBOsphereNorm, VBOsphereUvs, EBOsphere;
    let VBOringVert, VBOringNorm, VBOringUvs, EBOring;

    VAO = gl.createVertexArray();
    VBOsphereVert = gl.createBuffer(); VBOsphereNorm = gl.createBuffer(); VBOsphereUvs = gl.createBuffer(); EBOsphere = gl.createBuffer();
    gl.bindVertexArray(VAO);
    // position attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereVert);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);
    // normal attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereNorm);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.normals), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(1);
    // texCoord attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereUvs);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.uvs), gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(2);
    // index attribute
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBOsphere);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphereGeo.indices), gl.STATIC_DRAW);
    
    // Unbind 
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindVertexArray(null);
    
   // VECTORS OF LOOKAT MATRIX
   
    var cameraPos   = new Float32Array([0.0, 80.0, 0.0]);
    var cameraFront = new Float32Array([0.0, 0.0, 0.0]);
    var cameraUp    = new Float32Array([0.0, 1.0, 0.0]);
    var yaw = 0.0; var pitch = -90.0; 

    const timeAccel = 200;
    const astronomicUnit = 30;
    const moonDistance = 4;
    const sunPos = vec3.create();
    const earthPos = vec3.create();
    const moonPos =  vec3.create();
    const earthYearDuration = 365.0; // in earth days
    const moonYearDuration = 28.0; // in earth days
    const earthDayNumber = 365.0; // days in one year

    const PLANET_TEXTURE = "planetTexture"
    const FOLDER = "resources/"
    const TEXTURES = {
        EARTH: {
            CLOUDS: {SRC: FOLDER + "earth_clouds.png", UV_NAME: "cloudsTexture"},
            DIFFUSE: {SRC: FOLDER + "earth_diffuse.jpg", UV_NAME: "diffuseTexture"},
            NORMAL: {SRC: FOLDER + "earth_normal.jpg", UV_NAME: "normalTexture"},
            SPECULAR: {SRC: FOLDER + "earth_specular.jpg", UV_NAME: "specularTexture"},
        },
        MOON: {SRC: FOLDER + "moon.png", UV_NAME: PLANET_TEXTURE},
        SUN: {SRC: FOLDER + "sun.png", UV_NAME: PLANET_TEXTURE},
        JUPITER: {SRC: FOLDER + "jupiter.png", UV_NAME: PLANET_TEXTURE},
        SATURN: {SRC: FOLDER + "saturn.png", UV_NAME: PLANET_TEXTURE},
    }
    
    let texturesIds = new Array(Object.values(TEXTURES).length);
      
    const textureCallback = function(tex, texId){
        return function(){
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    };    

    for(const [key, val] of Object.entries(TEXTURES)){
        if (key === "EARTH"){
            for(const [skey, sval] of Object.entries(TEXTURES.EARTH)){
                sval.id = gl.createTexture();
                let texture = new Image();
                texture.onload = textureCallback(texture, sval.id);
                texture.src = sval.SRC;
            }
        }else{
            val.id = gl.createTexture();
            let texture = new Image();
            texture.onload = textureCallback(texture, val.id);
            texture.src = val.SRC;
        }        
    }

    // --------------------------------------------------------------------
    // ------------------------{ RENDER FUNC }-----------------------------
    // --------------------------------------------------------------------
    function renderFunc( time )
    {
        gl.viewport(0, 0, 1024 , 1024);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );

        time *= timeAccel * 0.001; // to seconds
    	
        // ----{ CAMERA MATRICES }----
        // PROJ MATRIX
        let proj = mat4.create();
        mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

        // VIEW MATRIX
        const yawRadians = Math.radians(yaw);
        const pitchRadians = Math.radians(pitch);
        const cosYaw = Math.cos(yawRadians);
        const sinYaw = Math.sin(yawRadians);
        const cosPitch = Math.cos(pitchRadians);
        const sinPitch = Math.sin(pitchRadians);
        
        let direction = vec3.create();
        direction[0] = cosYaw * cosPitch;
        direction[1] = sinPitch;
        direction[2] = sinYaw * cosPitch;
        vec3.normalize(cameraFront, direction);

        let camPosFront = vec3.create();
        vec3.add(camPosFront, cameraPos, cameraFront);
        
        let view = mat4.create();
        mat4.lookAt(view, cameraPos, camPosFront, cameraUp);

        shaderProgram.bind( );

        ubo.uploadData("projection", proj);
        ubo.uploadData("view", view);
        ubo.uploadAll( );

        // PLANETS
        let modelSun = mat4.create();
        let modelMercury = mat4.create();
        let modelVenus = mat4.create();
        let modelEarth = mat4.create();
        let modelEarthAtm = mat4.create();
        let modelMoon = mat4.create();
        let modelMars = mat4.create();
        let modelJupiter = mat4.create();
        let modelSaturn = mat4.create();
        let modelUranus = mat4.create();
        let modelNeptune = mat4.create();

        //SUN
        mat4.translate(modelSun, modelSun, sunPos);
        // PLANETS
        let models = [modelMercury, modelVenus, modelMars, modelJupiter, modelSaturn, modelUranus, modelNeptune];
        let years = [88.0, 224.7, 4332.0, 29.5 * 365.0, 84.0 * 365.0, 165.0 * 365.0];
        let days = [59.0, -243.0, 1, 10.0/24.0, 10.3 / 24.0, 17.0/24, 16.0/24.0];
        let distances = [0.38, 0.72, 1.52 , 5.21,  9.54, 19.18, 30.11];
        for(let i = 0; i < 7; i ++) {
            const planetTime = time / years[i];
            const relativePlanetPos =  new Float32Array([Math.cos(planetTime), 0.0, Math.sin(planetTime)])
                .map(x => x * 1 * distances[i] * astronomicUnit);

            mat4.translate(models[i], models[i], relativePlanetPos);
            mat4.multiply(models[i], models[i], modelSun);
            mat4.rotate(models[i], models[i], Math.radians(planetTime * days[i]), new Float32Array([0.0 ,1.0, 0.0]));

        }
        //EARTH
        // setting its relative position
        const earthTime = time / earthYearDuration;
        const relativeEarthPos = new Float32Array([Math.cos(earthTime), 0.0, Math.sin(earthTime)])
            .map(x => x * 1 * astronomicUnit);
        // setting its position with the sun 
        mat4.translate(modelEarth, modelEarth, relativeEarthPos);
        mat4.multiply(modelEarth, modelEarth, modelSun);
        mat4.scale(modelEarthAtm, modelEarth,[1.1, 1.1, 1.1]);
        //Making rotation of the earth
        mat4.rotate(modelEarth, modelEarth, Math.radians(time), new Float32Array([0.0 ,1.0, 0.0]));
        //Making rotation of the atmosphere
        mat4.rotate(modelEarthAtm, modelEarthAtm, Math.radians(time * 0.5), new Float32Array([0.0 ,1.0, 0.0]));

        //MOON
        const moonTime = time / 28;
        const relativeMoonPos = new Float32Array([Math.cos(moonTime), 0.0, Math.sin(moonTime)])
            .map(x => x * moonDistance);
        vec3.add(moonPos, earthPos, relativeMoonPos);
        mat4.translate(modelMoon, modelMoon, relativeMoonPos);
        mat4.multiply(modelMoon, modelMoon, modelEarth);
        //the moon always looks at the earth
        var moonDirection = vec3.create();
        vec3.subtract(moonDirection, earthPos, moonPos);
        vec3.normalize(moonDirection, moonDirection);
        const moonAngle = vec3.dot(moonDirection, [1.0, 0.0, 0.0]);
        mat4.rotate(modelMoon, modelMoon, Math.radians(moonAngle), [0.0 ,1.0, 0.0]);
        
        //SCALES
        mat4.scale(modelSun, modelSun, [5, 5, 5]);
        mat4.scale(modelEarth, modelEarth,[2, 2, 2]);
        mat4.scale(modelMoon, modelMoon,[0.8, 0.8, 0.8]);

        
        //DRAW PLANETS
        gl.bindVertexArray(VAO);
        shaderProgram.setUniformMat4("model", modelSun);
        // let i = 0;
        // for(const [key, val] of Object.entries(TEXTURES)){
        //     if(key == "EARTH") continue;

        //     gl.activeTexture(gl.TEXTURE0 + i);
        //     shaderProgram.setUniform1i( PLANET_TEXTURE, i);
        //     gl.bindTexture( gl.TEXTURE_2D, val.id);
        //     i++
        // }

        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        shaderProgram.setUniformMat4("model", modelMoon);
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        for(let i = 0; i < mo; i ++) {
            shaderProgram.setUniformMat4("model", models[i]);

            //PARA CADA PLANETA, ACTIBAR SUS TEXTURAS PARTIENDO DE 0, DESP DIBUJAR

            gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        }

        //DRAW EARTH
        earthShaderProgram.bind();
        
        let i = 0
        earthShaderProgram.setUniformMat4("model", modelEarth);
        for(const [key, val] of Object.entries(TEXTURES.EARTH)){
            gl.activeTexture(gl.TEXTURE0 + i);
            earthShaderProgram.setUniform1i( val.UV_NAME, i);
            gl.bindTexture( gl.TEXTURE_2D, val.id);
            i++
        }
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        earthShaderProgram.setUniformMat4("model", modelEarthAtm);
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);


        gl.bindVertexArray(null);
        requestAnimationFrame( renderFunc );
    }

    document.addEventListener('keydown', function(event) {
        /*
            65 => A
            68 => D
            83 => S
            87 => W
            81 => Q
            69 => E

            37 => Flecha izq
            39 => Fecha drcha
            38 => Fecha arriba
            40 => Fecha abajo

        */
        if( event.keyCode == 81 ) // Q
        {
        }
        
    } );

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.clientWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>