<!DOCTYPE html>
<html>
<head>
    <title>Prác.2 Remi y Stefano</title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">/*canvas {width: 100%;height: 100%;display: block;}body{margin: 0;overflow: hidden;}*/</style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4; const vec3 = glMatrix.vec3; const vec2 = glMatrix.vec2;
        Math.radians = function(degrees) {return degrees * Math.PI / 180;};
        Math.degrees = function(radians) {return radians * 180 / Math.PI;};
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

uniform mat4 model;

uniform UBO {
    mat4 projection;
    mat4 view;
};  

out vec3 normal;
out vec3 fragPos;
out vec2 vTexCoord;

void main( )
{
    fragPos = vec3(model * vec4(aPos, 1.0));
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    mat3 normalM = mat3(transpose(inverse(model)));
    normal = normalM * aNormal;

    vTexCoord = aTexCoord;
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec3 normal;
in vec3 fragPos;
in vec2 vTexCoord;

out vec4 fragColor;

void main(){
    fragColor = vec4(1.0,1.0,1.0,1.0);
}
</script>

</head>
<body>
<canvas id="myCanvas" width="1024" height="1024"></canvas>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );

    // ---------------------------------------------------
    // CREAR TODOS LOS SHADERPROGRAMS QUE NECESITES
    // ---------------------------------------------------
    let shaderProgram = new ShaderProgram( );
    shaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    shaderProgram.createFragmentShader(document.getElementById( "shader-fs" ).text);
    shaderProgram.compile(); shaderProgram.link();

    shaderProgram.autocatching();

    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view" ]); 

    ubo.attachProgram( shaderProgram );

    // ---------------------------------------------------
    const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    let VAO, VBO, VBO2, VBO3, VBO4, EBO;
    VAO = gl.createVertexArray();
    VBO = gl.createBuffer();
    VBO2 = gl.createBuffer();
    VBO3 = gl.createBuffer();
    EBO = gl.createBuffer();
    gl.bindVertexArray(VAO);
    // position attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);
    // normal attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.normals), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(1);
    // texCoord attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.uvs), gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(2);
    // index attribute
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphereGeo.indices), gl.STATIC_DRAW);
    // Unbind the VBO
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    // Unbind the VAO
    gl.bindVertexArray(null);

    // CREA EL VAO, VBO'S Y EBO PARA LA ESFERA (createSphere())
    // CREA EL VAO, VOB'S Y EBO PARA EL ANILLO (createRing())
    //  {
    //    "vertices": vertices,
    //    normals: normals,
    //    texCoords: uvs,
    //    indices: indices
    // }
    // ---------------------------------------------------
    // TODO: Crea una esfera y sube la geometría a la tarjeta gráfica
   // VECTORS OF LOOKAT MATRIX
   
    var cameraPos   = new Float32Array([0.0, 500.0, 0.0]);
    var cameraFront = new Float32Array([0.0, 0.0, 0.0]);
    var cameraUp    = new Float32Array([0.0, 1.0, 0.0]);
    var yaw = 0.0; var pitch = -90.0; 

    const timeAccel = 1;
    const earthDistance = 10;
    const moonDistance = 2;
    const sunPos = vec3.create();
    const earthPos = vec3.create();
    const moonPos =  vec3.create();
    const earthYearDuration = 365.0; // in earth days
    const moonYearDuration = 28.0; // in earth days
    const earthDayNumber = 365.0; // days in one year

    let modelSun = mat4.create();
    let modelEarth = mat4.create();
    let modelMoon = mat4.create();


    gl.clearColor( 1.0, 0.5, 0.0, 1.0 );
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    // --------------------------------------------------------------------
    // ------------------------{ RENDER FUNC }-----------------------------
    // --------------------------------------------------------------------
    function renderFunc( time )
    {
        gl.viewport(0, 0, 1024 , 1024);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );

        time *= timeAccel * 0.001; // to seconds

    	
        // ----{ CAMERA MATRICES }----
        // PROJ MATRIX
        let proj = mat4.create();
        mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

        // VIEW MATRIX
        const yawRadians = Math.radians(yaw);
        const pitchRadians = Math.radians(pitch);
        const cosYaw = Math.cos(yawRadians);
        const sinYaw = Math.sin(yawRadians);
        const cosPitch = Math.cos(pitchRadians);
        const sinPitch = Math.sin(pitchRadians);
        
        let direction = vec3.create();
        direction[0] = cosYaw * cosPitch;
        direction[1] = sinPitch;
        direction[2] = sinYaw * cosPitch;
        vec3.normalize(cameraFront, direction);

        let camPosFront = vec3.create();
        vec3.add(camPosFront, cameraPos, cameraFront);
        
        let view = mat4.create();
        mat4.lookAt(view, cameraPos, camPosFront, cameraUp);

     
        shaderProgram.bind( );

        ubo.uploadData("projection", proj);
        ubo.uploadData("view", view);
        ubo.uploadAll( );

        // PLANETS
        mat4.translate(modelSun, modelSun, sunPos);

        
        const earthTime = time / earthYearDuration;
       
        const relativeEarthPos = new Float32Array([Math.cos(earthTime), 0.0, Math.sin(earthTime)]);
        //console.log(sunPos);
        relativeEarthPos[0] *= earthDistance;
        relativeEarthPos[2] *= earthDistance ;
        console.log(relativeEarthPos);

        //relativeEarthPos = relativeEarthPos.map(x => x * earthDistance);
        vec3.add(earthPos, sunPos, relativeEarthPos);
        mat4.translate(modelEarth, modelEarth, earthPos);
        //mat4.rotate(modelEarth, modelEarth, Math.radians(time), new Float32Array([0.0 ,1.0, 0.0]));
        /*
        const moonTime = time / 28;
        const relativeMoonPos = new Float32Array([Math.cos(moonTime), 0.0, Math.sin(moonTime)])
            .map(x => x * moonDistance);
            
        vec3.add(moonPos, earthPos, relativeMoonPos);

        mat4.translate(modelMoon, modelMoon, moonPos);
        var moonDirection = vec3.create();
        vec3.subtract(moonDirection, earthPos, moonPos);
        vec3.normalize(moonDirection, moonDirection);
        const moonAngle = vec3.dot(moonDirection, [1.0, 0.0, 0.0]);
        //mat4.rotate(modelMoon, modelMoon, Math.radians(moonAngle), [0.0 ,1.0, 0.0]);
        */
        /*
        vec
        mat4.scale(modelSun, modelSun, new Float32Array([5.0, 5.0]));
        mat4.scale(modelEarth, modelEarth, new Float32Array([2.0, 2.0]));
*/
        gl.bindVertexArray(VAO);

        shaderProgram.setUniformMat4("model", modelSun);
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        shaderProgram.setUniformMat4("model", modelEarth);
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        //shaderProgram.setUniformMat4("model", modelMoon);
        //gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);

        gl.bindVertexArray(null);
        requestAnimationFrame( renderFunc );
    }

    document.addEventListener('keydown', function(event) {
        /*
            65 => A
            68 => D
            83 => S
            87 => W
            81 => Q
            69 => E

            37 => Flecha izq
            39 => Fecha drcha
            38 => Fecha arriba
            40 => Fecha abajo

        */
        if( event.keyCode == 81 ) // Q
        {
        }
        
    } );

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.clientWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>