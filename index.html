<!DOCTYPE html>
<html>
<head>
    <title>Prác.2 Remi y Stefano</title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">/*canvas {width: 100%;height: 100%;display: block;}body{margin: 0;overflow: hidden;}*/</style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4; const vec3 = glMatrix.vec3; const vec2 = glMatrix.vec2;
        Math.radians = function(degrees) {return degrees * Math.PI / 180;};
        Math.degrees = function(radians) {return radians * 180 / Math.PI;};
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

uniform mat4 model;

uniform UBO {
    mat4 projection;
    mat4 view;
    vec3 sunLightPos;
};  

out vec3 normal;
out vec3 fragPos;
out vec2 vTexCoord;

void main( )
{
    fragPos = vec3(model * vec4(aPos, 1.0));
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    mat3 normalM = mat3(transpose(inverse(model)));
    normal = normalM * aNormal;

    vTexCoord = aTexCoord;
}
</script>

<script id="earth-shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    
    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
   
    out vec4 fragColor;
    uniform vec3 cameraPos;

    vec3 objectColor = vec3(0.0, 1.0, 1.0);

    uniform sampler2D cloudsTex;
    uniform sampler2D diffuseTex;
    uniform sampler2D normalTex;
    uniform sampler2D specularTex;


    // Ambient
    float ambientStrength = 0.1;
    vec3 ambientColor = vec3(1.0, 1.0, 1.0);

    // Diffuse 
    float diffuseStrength = 0.6;
    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);

    // Specular
    float specularStrength = 0.5;
    float specularRadius = 32.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0); 

    uniform UBO {
        mat4 projection;
        mat4 view;
        vec3 sunLightPos;
    };  
    
    void main(){
        vec3 norm = normalize(normal);

        // Ambient
        vec3 ambient = ambientStrength * ambientColor;

        // Diffuse
        vec3 lightDir = normalize(sunLightPos - fragPos);
        vec3 diffuse =  max(dot(norm, lightDir), 0.0) * diffuseColor * diffuseStrength;

        // specular
        vec3 viewDir = normalize(fragPos - cameraPos );
        vec3 reflectDir = reflect(lightDir, norm);
        vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), specularRadius) * specularColor;
        
        fragColor = vec4((ambient + specular + diffuse), 1.0) * texture(diffuseTex, vTexCoord).rgba;

    }
</script>
<script id="sun-shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    
    uniform sampler2D diffuseTex;
    
    void main(){
        fragColor = texture(diffuseTex, vTexCoord).rgba;
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    
    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    
    uniform sampler2D diffuseTex;
    uniform vec3 cameraPos;

    // Ambient
    float ambientStrength = 0.1;
    vec3 ambientColor = vec3(1.0, 1.0, 1.0);

    // Diffuse 
    float diffuseStrength = 0.6;
    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);

    // Specular
    float specularStrength = 0.5;
    float specularRadius = 32.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0); 

    uniform UBO {
        mat4 projection;
        mat4 view;
        vec3 sunLightPos;
    };  
    
    void main(){

        vec3 norm = normalize(normal);

        // Ambient
        vec3 ambient = ambientStrength * ambientColor;

        // Diffuse
        vec3 lightDir = normalize(sunLightPos - fragPos);
        vec3 diffuse =  max(dot(norm, lightDir), 0.0) * diffuseColor * diffuseStrength;

        // specular
        vec3 viewDir = normalize(fragPos - cameraPos );
        vec3 reflectDir = reflect(lightDir, norm);
        vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), specularRadius) * specularColor;

        vec4 texColor = texture(diffuseTex, vTexCoord);

        if (texColor.a < 0.7)
            discard;
        
        fragColor = vec4((ambient + specular + diffuse), 1.0) * texColor;
    }
    </script>

</head>
<body>
<canvas id="myCanvas" width="1024" height="1024"></canvas>
<script type="text/javascript" src="controls.js"></script>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );
    let shaderProgram = new ShaderProgram( );
    let earthShaderProgram = new ShaderProgram();
    let sunShaderProgram = new ShaderProgram();
    shaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    shaderProgram.createFragmentShader(document.getElementById( "shader-fs" ).text);
    earthShaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    earthShaderProgram.createFragmentShader(document.getElementById( "earth-shader-fs" ).text);
    sunShaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    sunShaderProgram.createFragmentShader(document.getElementById( "sun-shader-fs" ).text);
    shaderProgram.compile(); shaderProgram.link(); shaderProgram.autocatching();
    earthShaderProgram.compile(); earthShaderProgram.link(); earthShaderProgram.autocatching();
    sunShaderProgram.compile(); sunShaderProgram.link(); sunShaderProgram.autocatching();

    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view", "sunLightPos"]); 
    ubo.attachProgram(shaderProgram); ubo.attachProgram(earthShaderProgram); ubo.attachProgram(sunShaderProgram);
    gl.clearColor( 1.0, 0.5, 0.0, 1.0 ); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    

    // ---------------------------------------------------
    const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    let VAO;
    let VBOsphereVert, VBOsphereNorm, VBOsphereUvs, EBOsphere;
    let VBOringVert, VBOringNorm, VBOringUvs, EBOring;

    VAO = gl.createVertexArray();
    VBOsphereVert = gl.createBuffer(); VBOsphereNorm = gl.createBuffer(); VBOsphereUvs = gl.createBuffer(); EBOsphere = gl.createBuffer();
    gl.bindVertexArray(VAO);
    // position attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereVert);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);
    // normal attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereNorm);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.normals), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(1);
    // texCoord attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereUvs);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.texCoords), gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(2);
    // index attribute
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBOsphere);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphereGeo.indices), gl.STATIC_DRAW);
    
    // Unbind 
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindVertexArray(null);
    
   // VECTORS OF LOOKAT MATRIX

    var initialCamPos   = new Float32Array([0.0, 0.0, 200.0]);
    var initialCamFront = new Float32Array([0.0, 0.0, 0.0]);
    var initialCamUp    = new Float32Array([0.0, 1.0, 0.0]);
    var yaw = -90.0; var pitch = 0.0; 

    var cameraPos   = initialCamPos  ;
    var cameraFront = initialCamFront;
    var cameraUp    = initialCamUp   ;
    // ROTATION OF CAMERA

    // DATA
    const timeAccel = 1000000; // 2 000 000
    const sec2day = 1 / (3600 * 24);
    const AU = 20;
    var sunPos = new Float32Array([0.0, 0.0, 0.0]);

    let celBodies = {
        sun: {
            scale: 5,
            program: sunShaderProgram,
            textures: {diffuseTex: {file: "sun.png"},},
            sphereShape: true,
        },mercury: {
            orbitT: 88.0, orbitR: 0.38, 
            dayLength: 59.0,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "mercury."},},
            sphereShape: true,
        },venus: {
            orbitT: 224.7, orbitR: 0.72,
            dayLength: -243.0,//había un menos en el valor original, no sé si está bien
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "venus."},},
            sphereShape: true,
        },earth: {
            orbitT: 365.25, orbitR: 1.0,
            dayLength: 1.0,
            scale: 2.0,
            program: earthShaderProgram,
            textures: {diffuseTex:{file: "earth_diffuse.jpg"}, normalTex: {file: "earth_normal.jpg"}, specularTex: {file: "earth_specular.jpg"},},
            sphereShape: true,
        },moon: {//NOT an orbit around the sun, manage special case in for-loops!
            orbitT: 28.0, orbitR: 0.2,
            scale: 0.2,
            orbitedBody: "earth",
            lookAt: true,
            program: shaderProgram,
            textures: {diffuseTex: {file: "moon.png"},},
            sphereShape: true,
        },mars: {
            orbitT: 687, orbitR: 1.52,
            dayLength: 1.026,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "mars."},},
            sphereShape: true,
        },jupiter: {
            orbitT: 4331, orbitR: 5.21,
            dayLength: 0.42,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "jupiter.png"},},
            sphereShape: true,
        },saturn: {
            orbitT: 10756, orbitR: 9.54,
            dayLength: 0.446,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "saturn.png"},},
            sphereShape: true,
        },uranus: {
            orbitT: 30678, orbitR: 19.18,
            dayLength: 0.7183,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "uranus."},},
            sphereShape: true,
        },neptune: {
            orbitT: 60190, orbitR: 30.11,
            dayLength: 0.67,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "neptune."},},
            sphereShape: true,
        }, earthAtm: {
            dayLength: 1.01,
            program: shaderProgram,
            textures: {diffuseTex: {file: "earth_clouds.png"},},
            sphereShape: true,
            transparent: true
        },
    }
    celBodies.earthAtm.orbitR = celBodies.earth.orbitR;
    celBodies.earthAtm.orbitT = celBodies.earth.orbitT
    celBodies.earthAtm.scale = celBodies.earth.scale*1.01

    const createImgOnLoadCallback = function(img, texId){
        return function(){
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    };   

    for(let [name, dict] of Object.entries(celBodies)) {
        
        dict.scale = new Float32Array([dict.scale, dict.scale, dict.scale]);

        if (name != "sun" && ! dict.hasOwnProperty("orbitedBody")) 
            dict.orbitedBody = "sun";
        
        for(let [uvName, texDict] of Object.entries(dict.textures)){
            texDict.id = gl.createTexture();
            let img = new Image();
            img.onload = createImgOnLoadCallback(img, texDict.id);
            const FOLDER = "resources/"
            img.src = FOLDER + texDict.file;
        }        
    
    }

    // --------------------------------------------------------------------------------------------------------------------------
    // -----------------------------------------{ RENDER FUNC }------------------------------------------------------------------
    // --------------------------------------------------------------------------------------------------------------------------
    function renderFunc( time )
    {
        gl.viewport(0, 0, 1024 , 1024);
        //gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );


        time *= timeAccel * 0.001 * sec2day; // to seconds

    	
        // ----{ CAMERA MATRICES }----
        // PROJ MATRIX
        let proj = mat4.create();
        mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

        // VIEW MATRIX
        const yawRadians = Math.radians(yaw);
        const pitchRadians = Math.radians(pitch);
        const cosYaw = Math.cos(yawRadians);
        const sinYaw = Math.sin(yawRadians);
        const cosPitch = Math.cos(pitchRadians);
        const sinPitch = Math.sin(pitchRadians);
        
        let direction = vec3.create();
        direction[0] = cosYaw * cosPitch; direction[1] = sinPitch; direction[2] = sinYaw * cosPitch;
        vec3.normalize(cameraFront, direction);

        let camPosFront = vec3.create();
        vec3.add(camPosFront, cameraPos, cameraFront);
        
        let view = mat4.create();
        mat4.lookAt(view, cameraPos, camPosFront, cameraUp);
     
        
        ubo.uploadData("projection", proj);
        ubo.uploadData("view", view);
        ubo.uploadData("sunLightPos", sunPos);
        ubo.uploadAll( );


        gl.bindVertexArray(VAO);
        for(let [name, dict] of Object.entries(celBodies)) {
            dict.model = mat4.create();

            dict.pos = vec3.create();
            
            if(dict.hasOwnProperty('orbitR')){ 
                const planetTime = time / dict.orbitT;
                const orbitRelativePos =  new Float32Array([Math.cos(planetTime), 0.0, Math.sin(planetTime)]).map(x => x * dict.orbitR * AU);
                vec3.add(dict.pos, orbitRelativePos, celBodies[dict.orbitedBody].pos);

                mat4.translate(dict.model, dict.model, dict.pos);
                
                if (dict.hasOwnProperty('lookAt') && dict.lookAt){
                    let direction = vec3.create();
                    vec3.subtract(direction, celBodies[dict.orbitedBody].pos, dict.pos);
                    vec3.normalize(direction, direction);
                    const angle = vec3.dot(direction, [1.0, 0.0, 0.0]);
                    mat4.rotate(dict.model, dict.model, Math.radians(angle), [0.0, 1.0, 0.0])
                }
                else{
                    mat4.rotate(dict.model, dict.model, Math.radians(planetTime * dict.dayLength), new Float32Array([0.0, 1.0, 0.0]));
                }
            }
            else mat4.translate(dict.model, dict.model, dict.pos);

            mat4.scale(dict.model, dict.model, dict.scale)

            dict.program.bind();
            dict.program.setUniformMat4("model", dict.model);
            dict.program.setUniform3f("cameraPos", ...cameraPos);


            let i = 0;
            for(const [uvName, texDict] of Object.entries(dict.textures)){
                gl.activeTexture(gl.TEXTURE0 + i);
                dict.program.setUniform1i(uvName, i);
                gl.bindTexture(gl.TEXTURE_2D, texDict.id);
                i++
            }

            if (dict.hasOwnProperty('transparent')){
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }

            if(dict.sphereShape) {
                gl.bindVertexArray(VAO);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBOsphere);
                gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
            }
            else {
                gl.bindVertexArray(VAORing);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBOring);
                gl.drawElements(gl.TRIANGLES, ringGeo.indices.length, gl.UNSIGNED_INT, 0);
            }

            if (dict.hasOwnProperty('transparent')){
                gl.disable(gl.BLEND);
            }
        }

        gl.bindVertexArray(null);
        requestAnimationFrame( renderFunc );
    }

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.clientWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>