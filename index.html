<!DOCTYPE html>
<html>
<head>
    <title>Pr√°c.2 Remi y Stefano</title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">/*canvas {width: 100%;height: 100%;display: block;}body{margin: 0;overflow: hidden;}*/</style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4; const vec3 = glMatrix.vec3; const vec2 = glMatrix.vec2;
        Math.radians = function(degrees) {return degrees * Math.PI / 180;};
        Math.degrees = function(radians) {return radians * 180 / Math.PI;};
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

uniform mat4 model;

uniform UBO {
    mat4 projection;
    mat4 view;
    vec3 sunLightPos;
};  

out vec3 normal;
out vec3 fragPos;
out vec2 vTexCoord;

void main( )
{
    fragPos = vec3(model * vec4(aPos, 1.0));
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    mat3 normalM = mat3(transpose(inverse(model)));
    normal = normalM * aNormal;

    vTexCoord = aTexCoord;
}
</script>

<script id="earth-shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    
    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    uniform sampler2D uTexture;
    uniform sampler2D diffuseTexture;
    uniform sampler2D normalTexture;
    uniform sampler2D specularTexture;

    out vec4 fragColor;
    uniform vec3 cameraPos;

    vec3 objectColor = vec3(0.0, 1.0, 1.0);

    // Ambient
    float ambientStrength = 0.1;
    vec3 ambientColor = vec3(1.0, 1.0, 1.0);

    // Diffuse 
    float diffuseStrength = 0.6;
    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);

    // Specular
    float specularStrength = 0.5;
    float specularRadius = 32.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0); 

    uniform UBO {
        mat4 projection;
        mat4 view;
        vec3 sunLightPos;
    };  
    
    void main(){
        vec3 norm = normalize(normal);

        // Ambient
        vec3 ambient = ambientStrength * ambientColor;

        // Diffuse
        vec3 lightDir = normalize(sunLightPos - fragPos);
        vec3 diffuse =  max(dot(norm, lightDir), 0.0) * diffuseColor * diffuseStrength;

        // specular
        vec3 viewDir = normalize(fragPos - cameraPos );
        vec3 reflectDir = reflect(lightDir, norm);
        vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), specularRadius) * specularColor;
        
        vec3 color = (ambient + specular + diffuse) * objectColor;
        fragColor = vec4(color, 1.0);

    }
</script>
<script id="sun-shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    
    uniform sampler2D uTexture;
    uniform sampler2D diffuseTexture;
    uniform sampler2D normalTexture;
    uniform sampler2D specularTexture;
    
    void main(){
        fragColor = vec4(1.0,1.0,1.0,1.0);
    }
    </script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    
    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    uniform sampler2D uTexture;
    uniform vec3 cameraPos;

    vec3 objectColor = vec3(0.0, 1.0, 1.0);

    // Ambient
    float ambientStrength = 0.1;
    vec3 ambientColor = vec3(1.0, 1.0, 1.0);

    // Diffuse 
    float diffuseStrength = 0.6;
    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);

    // Specular
    float specularStrength = 0.5;
    float specularRadius = 32.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0); 

    uniform UBO {
        mat4 projection;
        mat4 view;
        vec3 sunLightPos;
    };  
    
    void main(){
        vec3 norm = normalize(normal);

        // Ambient
        vec3 ambient = ambientStrength * ambientColor;

        // Diffuse
        vec3 lightDir = normalize(sunLightPos - fragPos);
        vec3 diffuse =  max(dot(norm, lightDir), 0.0) * diffuseColor * diffuseStrength;

        // specular
        vec3 viewDir = normalize(fragPos - cameraPos );
        vec3 reflectDir = reflect(lightDir, norm);
        vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), specularRadius) * specularColor;
        
        vec3 color = (ambient + specular + diffuse) * objectColor;
        fragColor = vec4(color, 1.0);

    }
    </script>

</head>
<body>
<canvas id="myCanvas" width="1024" height="1024"></canvas>
<script type="text/javascript" src="controls.js"></script>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );
    let shaderProgram = new ShaderProgram( );
    let earthShaderProgram = new ShaderProgram();
    let sunShaderProgram = new ShaderProgram();
    shaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    shaderProgram.createFragmentShader(document.getElementById( "shader-fs" ).text);
    earthShaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    earthShaderProgram.createFragmentShader(document.getElementById( "earth-shader-fs" ).text);
    sunShaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    sunShaderProgram.createFragmentShader(document.getElementById( "sun-shader-fs" ).text);
    shaderProgram.compile(); shaderProgram.link(); shaderProgram.autocatching();
    earthShaderProgram.compile(); earthShaderProgram.link(); earthShaderProgram.autocatching();
    sunShaderProgram.compile(); sunShaderProgram.link(); sunShaderProgram.autocatching();

    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view", "sunLightPos"]); 
    ubo.attachProgram(shaderProgram); ubo.attachProgram(earthShaderProgram); ubo.attachProgram(sunShaderProgram);
    gl.clearColor( 1.0, 0.5, 0.0, 1.0 ); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    

    // ---------------------------------------------------
    const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    let VAO;
    let VBOsphereVert, VBOsphereNorm, VBOsphereUvs, EBOsphere;
    let VBOringVert, VBOringNorm, VBOringUvs, EBOring;

    VAO = gl.createVertexArray();
    VBOsphereVert = gl.createBuffer(); VBOsphereNorm = gl.createBuffer(); VBOsphereUvs = gl.createBuffer(); EBOsphere = gl.createBuffer();
    gl.bindVertexArray(VAO);
    // position attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereVert);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);
    // normal attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereNorm);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.normals), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(1);
    // texCoord attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereUvs);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.uvs), gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(2);
    // index attribute
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBOsphere);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphereGeo.indices), gl.STATIC_DRAW);
    
    // Unbind 
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindVertexArray(null);
    
   // VECTORS OF LOOKAT MATRIX
    var initialCamPos   = new Float32Array([0.0, 0.0, 100.0]);
    var initialCamFront = new Float32Array([0.0, 0.0, 0.0]);
    var initialCamUp    = new Float32Array([0.0, 1.0, 0.0]);

    var cameraPos   = initialCamPos  ;
    var cameraFront = initialCamFront;
    var cameraUp    = initialCamUp   ;
    // ROTATION OF CAMERA

    // DATA
    const timeAccel = 2000000; // 2 000 000
    const sec2day = 1 / (3600 * 24);
    const astronomicUnit = 20;
    const moonDistance = 4;
    const sunPos = vec3.create();
    const earthPos = vec3.create();
    const moonPos =  vec3.create();
    const earthYearDuration = 365.0; // in earth days
    const moonYearDuration = 28.0; // in earth days
    const earthDayNumber = 365.0; // days in one year

    const FOLDER = "resources/"
    const SOURCES = {
        EARTH: {
            CLOUDS: FOLDER + "earth_clouds.png",
            DIFFUSE: FOLDER + "earth_diffuse.jpg",
            NORMAL: FOLDER + "earth_normal.jpg",
            SPECULAR: FOLDER + "earth_specular.jpg",
        },
        MOON: FOLDER + "moon.png",
        SUN: FOLDER + "sun.png",
        JUPITER: FOLDER + "jupiter.png",
        SATURN: FOLDER + "saturn.png",
    }
    
    let texturesIds = new Array(Object.values(SOURCES).length);
      
    const textureCallback = function(tex, texId){
            return function(){
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
            }
        };    

    for(const [key, val] of Object.entries(SOURCES)){
        if (key === "EARTH"){
            for(const [skey, sval] of Object.entries(SOURCES.EARTH)){
                SOURCES.EARTH[skey].id = gl.createTexture();
                let texture = new Image();
                texture.onload = textureCallback;
                texture.src = sval;
            }
        }
        else{
            SOURCES[key].id = gl.createTexture();
            let texture = new Image();

            texture.onload = textureCallback;
            
            texture.src = val;
        }        
        
    }

    // --------------------------------------------------------------------------------------------------------------------------
    // -----------------------------------------{ RENDER FUNC }------------------------------------------------------------------
    // --------------------------------------------------------------------------------------------------------------------------
    function renderFunc( time )
    {
        gl.viewport(0, 0, 1024 , 1024);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );

        time *= timeAccel * 0.001 * sec2day; // to seconds

    	
        // ----{ CAMERA MATRICES }----
        // PROJ MATRIX
        let proj = mat4.create();
        mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

        // VIEW MATRIX
        const yawRadians = Math.radians(yaw);
        const pitchRadians = Math.radians(pitch);
        const cosYaw = Math.cos(yawRadians);
        const sinYaw = Math.sin(yawRadians);
        const cosPitch = Math.cos(pitchRadians);
        const sinPitch = Math.sin(pitchRadians);
        
        let direction = vec3.create();
        direction[0] = cosYaw * cosPitch;
        direction[1] = sinPitch;
        direction[2] = sinYaw * cosPitch;
        vec3.normalize(cameraFront, direction);

        let camPosFront = vec3.create();
        vec3.add(camPosFront, cameraPos, cameraFront);
        
        let view = mat4.create();
        mat4.lookAt(view, cameraPos, camPosFront, cameraUp);

        ubo.uploadData("projection", proj);
        ubo.uploadData("view", view);
        ubo.uploadData("sunLightPos", sunPos);
        ubo.uploadAll( );
     
        

        // PLANETS
        let modelSun = mat4.create();
        let modelMercury = mat4.create();
        let modelVenus = mat4.create();
        let modelEarth = mat4.create();
        let modelEarthAtm = mat4.create();
        let modelMoon = mat4.create();
        let modelMars = mat4.create();
        let modelJupiter = mat4.create();
        let modelSaturn = mat4.create();
        let modelUranus = mat4.create();
        let modelNeptune = mat4.create();

        //SUN
        mat4.translate(modelSun, modelSun, sunPos);
        // PLANETS
        let models = [modelMercury, modelVenus, modelMars, modelJupiter, modelSaturn, modelUranus, modelNeptune];
        let years =     [88.0, 224.7, 668.599, 29.5 * 365.0, 84.0 * 365.0, 165.0 * 365.0];
        let days =      [59.0,-243.0,       1,    10.0/24.0,  10.3 / 24.0, 17.0/24, 16.0/24.0];
        let distances = [0.38,  0.72,   1.52 ,         5.21,         9.54,  19.18, 30.11];
        for(let i = 0; i < 7; i ++) {
            const planetTime = time / years[i];
            const relativePlanetPos =  new Float32Array([Math.cos(planetTime), 0.0, Math.sin(planetTime)])
                .map(x => x * distances[i] * astronomicUnit);

            mat4.translate(models[i], models[i], relativePlanetPos);
            mat4.multiply(models[i], models[i], modelSun);
            mat4.rotate(models[i], models[i], Math.radians(planetTime * days[i]), new Float32Array([0.0 ,1.0, 0.0]));

        }
        //EARTH
        // setting its relative position
        const earthTime = time / earthYearDuration;
        const relativeEarthPos = new Float32Array([Math.cos(earthTime), 0.0, Math.sin(earthTime)])
            .map(x => x * 1 * astronomicUnit);
        // setting its position with the sun 
        mat4.translate(modelEarth, modelEarth, relativeEarthPos);
        mat4.multiply(modelEarth, modelEarth, modelSun);
        //Making rotation of the earth
        mat4.rotate(modelEarth, modelEarth, Math.radians(time), new Float32Array([0.0 ,1.0, 0.0]));
        //Making rotation of the atmosphere
        mat4.rotate(modelEarthAtm, modelEarthAtm, Math.radians(time * 0.5), new Float32Array([0.0 ,1.0, 0.0]));

        //MOON
        const moonTime = time / 28;
        const relativeMoonPos = new Float32Array([Math.cos(moonTime), 0.0, Math.sin(moonTime)])
            .map(x => x * moonDistance);
        vec3.add(moonPos, earthPos, relativeMoonPos);
        mat4.translate(modelMoon, modelMoon, relativeMoonPos);
        mat4.multiply(modelMoon, modelMoon, modelEarth);
        //the moon always looks at the earth
        var moonDirection = vec3.create();
        vec3.subtract(moonDirection, earthPos, moonPos);
        vec3.normalize(moonDirection, moonDirection);
        const moonAngle = vec3.dot(moonDirection, [1.0, 0.0, 0.0]);
        mat4.rotate(modelMoon, modelMoon, Math.radians(moonAngle), [0.0 ,1.0, 0.0]);
        
        //SCALES
        mat4.scale(modelSun, modelSun, [5, 5, 5]);
        mat4.scale(modelEarth, modelEarth,[2, 2, 2]);
        mat4.scale(modelEarthAtm, modelEarth,[1.1, 1.1, 1.1]);
        mat4.scale(modelMoon, modelMoon,[0.8, 0.8, 0.8]);

        //DRAW PLANETS & MOON
        shaderProgram.bind( );
        gl.bindVertexArray(VAO);
        shaderProgram.setUniform3f("cameraPos", ...cameraPos);

        const allModels = [modelMercury, modelVenus, modelMars, modelJupiter, modelSaturn, modelUranus, modelNeptune, modelMoon];

        for(let i = 0; i < allModels.length; i ++) {
            shaderProgram.setUniformMat4("model", allModels[i]);
            gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        }

        //DRAW EARTH
        earthShaderProgram.bind();
        shaderProgram.setUniform3f("cameraPos", ...cameraPos);
        earthShaderProgram.setUniformMat4("model", modelEarth);
        /*
        earthShaderProgram.setUniform1i( "uTexture", 0);
        earthShaderProgram.setUniform1i( "diffuseTexture", 1);
        earthShaderProgram.setUniform1i( "specularTexture", 2);
        earthShaderProgram.setUniform1i( "normalTexture", 3);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture( gl.TEXTURE_2D, texturesIds[0]);
        gl.activeTexture(gl.TEXTURE1);
        gl.activeTexture(gl.TEXTURE2);
        gl.activeTexture(gl.TEXTURE3);
        */
        
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
        earthShaderProgram.setUniformMat4("model", modelEarthAtm);
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);

        // DRAW SUN
        sunShaderProgram.bind();
        sunShaderProgram.setUniformMat4("model", modelSun);
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);


        gl.bindVertexArray(null);
        requestAnimationFrame( renderFunc );
    }

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.clientWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>