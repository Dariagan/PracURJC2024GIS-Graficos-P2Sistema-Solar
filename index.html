<!DOCTYPE html>
<html>
<head>
    <title>Prác.2 Remi y Stefano</title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">/*canvas {width: 100%;height: 100%;display: block;}body{margin: 0;overflow: hidden;}*/</style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4; const vec3 = glMatrix.vec3; const vec2 = glMatrix.vec2;
        Math.radians = function(degrees) {return degrees * Math.PI / 180;};
        Math.degrees = function(radians) {return radians * 180 / Math.PI;};
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

uniform mat4 model;

uniform UBO {
    mat4 projection;
    mat4 view;
    vec3 sunLightPos;
};  

out vec3 normal;
out vec3 fragPos;
out vec2 vTexCoord;

void main( )
{
    fragPos = vec3(model * vec4(aPos, 1.0));
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    mat3 normalM = mat3(transpose(inverse(model)));
    normal = normalM * aNormal;

    vTexCoord = aTexCoord;
}
</script>

<script id="earth-shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    
    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
   
    out vec4 fragColor;
    uniform vec3 cameraPos;

    vec3 objectColor = vec3(0.0, 1.0, 1.0);

    uniform sampler2D cloudsTex;
    uniform sampler2D diffuseTex;
    uniform sampler2D normalTex;
    uniform sampler2D specularTex;


    // Ambient
    float ambientStrength = 0.8;
    vec3 ambientColor = vec3(1.0, 1.0, 1.0);

    // Diffuse 
    float diffuseStrength = 0.6;
    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);

    // Specular
    float specularStrength = 0.5;
    float specularRadius = 32.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0); 

    uniform UBO {
        mat4 projection;
        mat4 view;
        vec3 sunLightPos;
    };  
    
    void main(){
        vec3 norm = normalize(normal);

        // Ambient
        vec3 ambient = ambientStrength * ambientColor;

        // Diffuse
        vec3 lightDir = normalize(sunLightPos - fragPos);
        vec3 diffuse =  max(dot(norm, lightDir), 0.0) * diffuseColor * diffuseStrength;

        // specular
        vec3 viewDir = normalize(fragPos - cameraPos );
        vec3 reflectDir = reflect(lightDir, norm);
        vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), specularRadius) * specularColor;
        
        fragColor = vec4((ambient + specular + diffuse), 1.0) * texture(diffuseTex, vTexCoord).rgba;

    }
</script>
<script id="sun-shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    
    uniform sampler2D diffuseTex;
    
    void main(){
        fragColor = texture(diffuseTex, vTexCoord).rgba;
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    
    in vec3 normal;
    in vec3 fragPos;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    
    uniform sampler2D diffuseTex;
    uniform vec3 cameraPos;

    // Ambient
    float ambientStrength = 0.2;
    vec3 ambientColor = vec3(1.0, 1.0, 1.0);

    // Diffuse 
    float diffuseStrength = 0.7;
    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);

    // Specular
    float specularStrength = 0.6;
    float specularRadius = 32.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0); 

    uniform UBO {
        mat4 projection;
        mat4 view;
        vec3 sunLightPos;
    };  
    
    void main(){

        vec3 norm = normalize(normal);

        // Ambient
        vec3 ambient = ambientStrength * ambientColor;

        // Diffuse
        vec3 lightDir = normalize(sunLightPos - fragPos);
        vec3 diffuse =  max(dot(norm, lightDir), 0.0) * diffuseColor * diffuseStrength;

        // specular
        vec3 viewDir = normalize(fragPos - cameraPos );
        vec3 reflectDir = reflect(lightDir, norm);
        vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), specularRadius) * specularColor;

        vec4 texColor = texture(diffuseTex, vTexCoord);

        if (texColor.a < 0.7)
            discard;
        
        fragColor = vec4((ambient + specular + diffuse), 1.0) * texColor;
    }
    </script>

</head>
<body>
<canvas id="myCanvas" width="1024" height="1024"></canvas>
<script type="text/javascript" src="controls.js"></script>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );
    let shaderProgram = new ShaderProgram( );
    let earthShaderProgram = new ShaderProgram();
    let sunShaderProgram = new ShaderProgram();
    shaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    shaderProgram.createFragmentShader(document.getElementById( "shader-fs" ).text);
    earthShaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    earthShaderProgram.createFragmentShader(document.getElementById( "earth-shader-fs" ).text);
    sunShaderProgram.createVertexShader(document.getElementById( "shader-vs" ).text);
    sunShaderProgram.createFragmentShader(document.getElementById( "sun-shader-fs" ).text);
    shaderProgram.compile(); shaderProgram.link(); shaderProgram.autocatching();
    earthShaderProgram.compile(); earthShaderProgram.link(); earthShaderProgram.autocatching();
    sunShaderProgram.compile(); sunShaderProgram.link(); sunShaderProgram.autocatching();

    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view", "sunLightPos"]); 
    ubo.attachProgram(shaderProgram); ubo.attachProgram(earthShaderProgram); ubo.attachProgram(sunShaderProgram);
    gl.clearColor( 1.0, 0.5, 0.0, 1.0 ); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    

    // ---------------------------------------------------
    const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    let VAOsphere = gl.createVertexArray();
    let VBOsphereVert = gl.createBuffer(); let VBOsphereNorm = gl.createBuffer(); let VBOsphereUvs = gl.createBuffer(); 
    let VAOring = gl.createVertexArray();
    let VBOringVert = gl.createBuffer(); let VBOringNorm = gl.createBuffer(); let VBOringUvs = gl.createBuffer(); 
    
    let EBOsphere = gl.createBuffer(); let EBOring = gl.createBuffer();
    gl.bindVertexArray(VAOsphere);
    // position attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereVert);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    // normal attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereNorm);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.normals), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
    // texCoord attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOsphereUvs);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.texCoords), gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
    // index attribute
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBOsphere);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphereGeo.indices), gl.STATIC_DRAW);
    
    gl.enableVertexAttribArray(0);gl.enableVertexAttribArray(1);gl.enableVertexAttribArray(2);

    gl.bindVertexArray(VAOring);

    gl.bindBuffer(gl.ARRAY_BUFFER, VBOringVert);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ringGeo.vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, VBOringNorm);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ringGeo.normals), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, VBOringUvs);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ringGeo.texCoords), gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBOring);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(ringGeo.indices), gl.STATIC_DRAW);

    gl.enableVertexAttribArray(0);gl.enableVertexAttribArray(1);gl.enableVertexAttribArray(2);

    // Unbind 
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindVertexArray(null);
    
   // VECTORS OF LOOKAT MATRIX

    const initialCamPos   = new Float32Array([0.0, 0.0, 50.0]);
    const initialCamFront = new Float32Array([0.0, 0.0, 0.0]);
    const initialCamUp    = new Float32Array([0.0, 1.0, 0.0]);
    var yaw = -90.0; var pitch = 0.0; 

    var cameraPos   = new Float32Array(initialCamPos)  ;
    var cameraFront = new Float32Array(initialCamFront);
    var cameraUp    = new Float32Array(initialCamUp)   ;
    // ROTATION OF CAMERA

    

    let celBodies = {
        sun: {
            scale: 5,
            program: sunShaderProgram,
            textures: {diffuseTex: {file: "sun.png"},},
            sphereShape: true,
        },mercury: {
            orbitT: 88.0, orbitR: 0.38, 
            axisRotationT: 59.0,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "mercury."},},
            sphereShape: true,
        },venus: {
            orbitT: 224.7, orbitR: 0.72,
            axisRotationT: 243.0,//había un menos en el valor original, no sé si está bien
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "venus."},},
            sphereShape: true,
        },earth: {
            orbitT: 365.25, orbitR: 1.0,
            axisRotationT: 1.0,
            scale: 2.0,
            program: earthShaderProgram,
            textures: {diffuseTex:{file: "earth_diffuse.jpg"}, normalTex: {file: "earth_normal.jpg"}, specularTex: {file: "earth_specular.jpg"},},
            sphereShape: true,
        },moon: {//NOT an orbit around the sun, manage special case in for-loops!
            orbitT: 28.0, orbitR: 0.2,
            scale: 0.2,
            orbitedBody: "earth",
            lookAt: true,
            program: shaderProgram,
            textures: {diffuseTex: {file: "moon.png"},},
            sphereShape: true,
        },mars: {
            orbitT: 687, orbitR: 1.52,
            axisRotationT: 1.026,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "mars."},},
            sphereShape: true,
        },jupiter: {
            orbitT: 4331, orbitR: 5.21,
            axisRotationT: 0.42,
            scale: 10,
            program: shaderProgram,
            textures: {diffuseTex: {file: "jupiter.png"},},
            sphereShape: true,
        },saturn: {
            orbitT: 10756, orbitR: 9.54,
            axisRotationT: 0.446,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "saturn.png"},},
            sphereShape: true,
        },saturnRing: {
            orbitT: 10756, orbitR: 9.54,
            axisRotationT: 0.446,
            scale: 40,
            program: shaderProgram,
            textures: {diffuseTex: {file: "saturn_ring.png"},},
            sphereShape: false,
        },uranus: {
            orbitT: 30678, orbitR: 19.18,
            axisRotationT: 0.7183,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "uranus."},},
            sphereShape: true,
        },neptune: {
            orbitT: 60190, orbitR: 30.11,
            axisRotationT: 0.67,
            scale: 1,
            program: shaderProgram,
            textures: {diffuseTex: {file: "neptune."},},
            sphereShape: true,
        }, earthAtm: {
            axisRotationT: 1.01,
            program: shaderProgram,
            textures: {diffuseTex: {file: "earth_clouds.png"},},
            sphereShape: true,
            transparent: true
        },
    }
    celBodies.earthAtm.orbitR = celBodies.earth.orbitR;
    celBodies.earthAtm.orbitT = celBodies.earth.orbitT
    celBodies.earthAtm.scale = celBodies.earth.scale*1.01

    const createImgOnLoadCallback = function(img, texId){
        return function(){
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    };   

    for(let [name, dict] of Object.entries(celBodies)) {
        
        dict.scale = new Float32Array([dict.scale, dict.scale, dict.scale]);

 

        if (name != "sun" && ! dict.hasOwnProperty("orbitedBody")) 
            dict.orbitedBody = "sun";
        
        for(let [uvName, texDict] of Object.entries(dict.textures)){
            texDict.id = gl.createTexture();
            let img = new Image();
            img.onload = createImgOnLoadCallback(img, texDict.id);
            const FOLDER = "resources/"
            img.src = FOLDER + texDict.file;
        }        
    
    }

    function getRandom(min, max) {
        return Math.random() * (max - min) + min;
    }
    
    const ASTEROID_COUNT = 1000;
    let asteroidModels = new Array(ASTEROID_COUNT)
    const radius = 50; const offset = 2.5;

    for (let i = 0; i < ASTEROID_COUNT; i++) {
        let model = mat4.create();
        
        const angle = i / ASTEROID_COUNT * 360.0;
        let displacement = getRandom(-offset, offset);
        const x = Math.sin(angle) * radius + displacement;
        displacement = getRandom(-offset, offset);
        const y = displacement * 0.4; 
        displacement = getRandom(-offset, offset);
        const z = Math.cos(angle) * radius + displacement;
        mat4.translate(model, model, [x, y, z]);

        const scale = getRandom(0.05, 0.25);
        mat4.scale(model, model, [scale, scale, scale]);

        const rotAngle = getRandom(0, 360);
        mat4.rotate(model, model, Math.radians(rotAngle), [0.4, 0.6, 0.8]);

        asteroidModels[i] = model;
    }

    // --------------------------------------------------------------------------------------------------------------------------
    // -----------------------------------------{ RENDER FUNC }------------------------------------------------------------------
    // --------------------------------------------------------------------------------------------------------------------------
    const oneOn60 = 1 / 60;
    const oneOn24 = 1 / 24;
    const timeAccel = 1;
    const AU = 20;
    function renderFunc( time )
    {
        gl.viewport(0, 0, 1024 , 1024);
        //gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );


        time *= timeAccel; // to milliseconds
        timeSec = time * 0.001; // to seconds
        timeMin = timeSec * oneOn60; // to minutes
        timeHour = timeMin * oneOn60; // to hours
        timeDay = timeHour * oneOn24; // to days
        
    	
        // ----{ CAMERA MATRICES }----
        // PROJ MATRIX
        let proj = mat4.create();
        mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

        // VIEW MATRIX
        const yawRadians = Math.radians(yaw);
        const pitchRadians = Math.radians(pitch);
        const cosYaw = Math.cos(yawRadians);
        const sinYaw = Math.sin(yawRadians);
        const cosPitch = Math.cos(pitchRadians);
        const sinPitch = Math.sin(pitchRadians);
        
        let direction = vec3.create();
        direction[0] = cosYaw * cosPitch; direction[1] = sinPitch; direction[2] = sinYaw * cosPitch;
        vec3.normalize(cameraFront, direction);

        let camPosFront = vec3.create();
        vec3.add(camPosFront, cameraPos, cameraFront);
        
        let view = mat4.create();
        mat4.lookAt(view, cameraPos, camPosFront, cameraUp);
     
        
        ubo.uploadData("projection", proj);
        ubo.uploadData("view", view);
        ubo.uploadData("sunLightPos", new Float32Array([0,0,0]));
        ubo.uploadAll( );

        // for (let i = 0; i < ASTEROID_COUNT; i++)
        // {
        //     shader.setUniformMat4("asteroidModel", asteroidModels[i]);
        //     gl.drawElementsInstanced()
        // }     


        for(let [name, dict] of Object.entries(celBodies)) {
            dict.model = mat4.create();

            dict.pos = vec3.create()
            
            if(dict.hasOwnProperty('orbitR')){ 
                const orbitAngle = 2 * Math.PI * timeDay / dict.orbitT;

                const orbitRelativePos =  new Float32Array([Math.cos(orbitAngle), 0.0, Math.sin(orbitAngle)]).map(x => x * dict.orbitR * AU);
                vec3.add(dict.pos, orbitRelativePos, celBodies[dict.orbitedBody].pos);

                mat4.translate(dict.model, dict.model, dict.pos);


                if (dict.hasOwnProperty('lookAt') && dict.lookAt){
                    let direction = vec3.create();
                    vec3.subtract(direction, celBodies[dict.orbitedBody].pos, dict.pos);
                    vec3.normalize(direction, direction);
                    const angle = -Math.atan2(direction[2], direction[0]);
                    mat4.identity(dict.model);
                    mat4.translate(dict.model, dict.model, dict.pos);
                    mat4.rotateY(dict.model, dict.model, angle);
                }
                else {
                    //const axisRotAngle = time*/;
                    const angle = 2 * Math.PI * timeDay / dict.axisRotationT;
                    mat4.rotate(dict.model, dict.model, angle, new Float32Array([0.0, 1.0, 0.0]));
                    mat4.rotate(dict.model, dict.model, Math.radians(0), new Float32Array([1.0, 0.0, 0.0]));
                    mat4.rotate(dict.model, dict.model, Math.radians(180), new Float32Array([0.0, 0.0, 1.0]));

                }

            }
            else mat4.translate(dict.model, dict.model, dict.pos);

            mat4.scale(dict.model, dict.model, dict.scale)

            dict.program.bind();
            dict.program.setUniformMat4("model", dict.model);
            dict.program.setUniform3f("cameraPos", ...cameraPos);


            let i = 0;
            for(const [uvName, texDict] of Object.entries(dict.textures)){
                gl.activeTexture(gl.TEXTURE0 + i);
                dict.program.setUniform1i(uvName, i);
                gl.bindTexture(gl.TEXTURE_2D, texDict.id);
                i++
            }

            if (dict.hasOwnProperty('transparent')){
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }

            if(dict.sphereShape) {
                gl.bindVertexArray(VAOsphere);
                gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
            }
            else {
                console.log("asd")
                gl.bindVertexArray(VAOring);
                gl.drawElements(gl.TRIANGLES, ringGeo.indices.length, gl.UNSIGNED_INT, 0);
            }

            if (dict.hasOwnProperty('transparent')){
                gl.disable(gl.BLEND);
            }
        }

        gl.bindVertexArray(null);
        requestAnimationFrame( renderFunc );
    }

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.clientWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>